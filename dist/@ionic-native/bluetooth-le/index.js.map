{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/@ionic-native/plugins/bluetooth-le/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Plugin, Cordova, CordovaProperty, IonicNativePlugin } from '@ionic-native/core';\r\n\r\nimport { Observable } from 'rxjs/Observable';\r\n\r\n/* Available status of device */\r\nexport type Status = 'scanStarted' | 'scanStopped' | 'scanResult' | 'connected' | 'disconnected'\r\n    | 'bonding' | 'bonded' | 'unbonded' | 'closed' | 'services' | 'discovered'\r\n    | 'characteristics' | 'descriptors' | 'read' | 'subscribed' | 'unsubscribed'\r\n    | 'subscribedResult' | 'written' | 'readDescriptor' | 'writeDescriptor'\r\n    | 'rssi' | 'mtu' | 'connectionPriorityRequested' |'enabled' | 'disabled'\r\n    | 'readRequested' | 'writeRequested' | 'mtuChanged' | 'notifyReady' | 'notifySent'\r\n    | 'serviceAdded' | 'serviceRemoved' | 'allServicesRemoved' | 'advertisingStarted'\r\n    | 'advertisingStopped' | 'responded' | 'notified';\r\n\r\n/** Available connection priorities */\r\nexport type ConnectionPriority = 'low' | 'balanced' | 'high';\r\n\r\nexport interface Params {\r\n  /** The address/identifier provided by the scan's return object */\r\n  address: string;\r\n  /** The service's ID */\r\n  service: string;\r\n}\r\n\r\nexport interface InitPeripheralParams {\r\n  /** Should user be prompted to enable Bluetooth */\r\n  request?: boolean;\r\n  /* A unique string to identify your app. Bluetooth Central background mode is required to use this, but background mode doesn't seem to require specifying the restoreKey */\r\n  restoreKey?: string;\r\n}\r\n\r\nexport interface InitParams extends InitPeripheralParams {\r\n    /** Should change in Bluetooth status notifications be sent */\r\n    statusReceiver?: boolean;\r\n}\r\n\r\nexport interface ScanParams {\r\n  /* An array of service IDs to filter the scan or empty array / null. This parameter is not supported on Windows platform yet */\r\n  services?: string[];\r\n  /** True/false to allow duplicate advertisement packets, defaults to false (iOS)*/\r\n  allowDuplicates?: boolean;\r\n  /** Defaults to Low Power. Available from API21 / API 23 (Android) */\r\n  scanMode?: BluetoothScanMode;\r\n  /** Defaults to Aggressive. Available from API23 (Android) */\r\n  matchMode?: BluetoothMatchMode;\r\n  /** Defaults to One Advertisement. Available from API23 (Android) */\r\n  matchNum?: BluetoothMatchNum;\r\n  /** Defaults to All Matches. Available from API21 / API 23. (Android) */\r\n  callbackType?: BluetoothCallbackType;\r\n}\r\n\r\nexport interface NotifyParams {\r\n  /** Service's UUID */\r\n  service: string;\r\n  /** Characteristic's UUID */\r\n  characteristic: string;\r\n  /** Base64 encoded string, number or string */\r\n  value: string;\r\n}\r\n\r\nexport interface RespondParams {\r\n  /** This integer value will be incremented every read/writeRequested */\r\n  requestId: number;\r\n  /** base64 string */\r\n  value: string;\r\n  /** not documented */\r\n  offset?: number;\r\n}\r\n\r\nexport interface CharacteristicParams extends Params {\r\n  /** An array of characteristic IDs to discover or empty array / null */\r\n  characteristics?: string[];\r\n}\r\n\r\nexport interface DescriptorParams extends Params {\r\n  /** The characteristic's ID */\r\n  characteristic: string;\r\n}\r\n\r\nexport interface OperationDescriptorParams  extends DescriptorParams {\r\n  /** The descriptor's ID */\r\n  descriptor: string;\r\n}\r\n\r\nexport interface WriteCharacteristicParams extends DescriptorParams {\r\n  /* Base64 encoded string */\r\n  value: string;\r\n  /* Set to \"noResponse\" to enable write without response, all other values will write normally. */\r\n  type?: string;\r\n}\r\n\r\nexport interface WriteDescriptorParams extends DescriptorParams {\r\n  /** The descriptor's ID */\r\n  descriptor: string;\r\n  /** Base64 encoded string, number or string */\r\n  value: string;\r\n}\r\n\r\nexport  type AdvertisingParams = AdvertisingParamsAndroid | AdvertisingParamsIOS;\r\nexport type AdvertiseMode = 'balanced' | 'lowLatency' | 'lowPower';\r\nexport type TxPowerLevel = 'high' | 'low' | 'ultralow' | 'medium';\r\n\r\nexport interface AdvertisingParamsAndroid {\r\n  /** Service UUID on Android */\r\n  service: string;\r\n  /** not documented */\r\n  mode?: AdvertiseMode;\r\n  /** not documented */\r\n  connectable?: boolean;\r\n  /** not documented */\r\n  timeout?: number;\r\n  /** not documented */\r\n  txPowerLevel?: TxPowerLevel;\r\n  /** not documented */\r\n  manufacturerId?: number;\r\n  /** not documented */\r\n  manufacturerSpecificData?: any;\r\n  /** not documented */\r\n  includeDeviceName: boolean;\r\n  /** not documented */\r\n  includeTxPowerLevel: boolean;\r\n}\r\n\r\nexport interface AdvertisingParamsIOS {\r\n  /** Array of service UUIDs on iOS */\r\n  services: string[];\r\n  /** device's name */\r\n  name?: string;\r\n}\r\n\r\nexport interface CommonInfo {\r\n  /** The device's display name */\r\n  name: string;\r\n  /** The device's address / identifier for connecting to the object */\r\n  address: string;\r\n}\r\n\r\nexport interface DeviceInfo extends CommonInfo {\r\n  /** Device's status */\r\n  status: Status;\r\n}\r\n\r\nexport interface RSSI extends DeviceInfo {\r\n  /** signal strength */\r\n  rssi: number;\r\n}\r\n\r\nexport interface MTU extends DeviceInfo {\r\n  /* mtu value */\r\n  mtu: number;\r\n}\r\n\r\nexport interface BondedStatus extends CommonInfo {\r\n  /** Bonded status*/\r\n  isBonded: boolean;\r\n}\r\n\r\nexport interface PrevConnectionStatus extends CommonInfo {\r\n  /** Determine whether the device was connected */\r\n  wasConnected: boolean;\r\n}\r\n\r\nexport interface CurrConnectionStatus extends CommonInfo {\r\n  /** Determine whether the device is connected */\r\n  isConnected: boolean;\r\n}\r\n\r\nexport interface DiscoverStatus extends CommonInfo {\r\n  /** Determine whether the device's characteristics and descriptors have been discovered */\r\n  isDiscovered: boolean;\r\n}\r\n\r\nexport interface ScanStatus extends DeviceInfo {\r\n  /** signal strength */\r\n  rssi: number;\r\n  /**\r\n   * advertisement data in encoded string of bytes, use bluetoothle.encodedStringToBytes() (Android)\r\n   * advertisement hash with the keys (iOS)\r\n   * empty (Windows)\r\n   */\r\n  advertisement: {\r\n      /** An array of service UUIDs */\r\n      serviceUuids: string[];\r\n      /** A string representing the name of the manufacturer of the device */\r\n      manufacturerData: string;\r\n      /** A number containing the transmit power of a peripheral */\r\n      txPowerLevel: number;\r\n      /** An array of one or more CBUUID objects, representing CBService UUIDs that were found in the “overflow” area of the advertisement data */\r\n      overflowServiceUuids: string[];\r\n      /** A boolean value that indicates whether the advertising event type is connectable */\r\n      isConnectable: boolean;\r\n      /** An array of one or more CBUUID objects, representing CBService UUIDs */\r\n      solicitedServiceUuids: string[];\r\n      /* A dictionary containing service-specific advertisement data */\r\n      serviceData: any;\r\n      /* A string containing the local name of a peripheral */\r\n      localName: string;\r\n  } | string;\r\n}\r\n\r\n\r\nexport interface Service {\r\n  /** Service's uuid */\r\n  uuid: string;\r\n  /** Array of characteristics */\r\n  characteristics: Characteristic[];\r\n}\r\n\r\nexport interface Characteristic {\r\n  /* Array of descriptors */\r\n  descriptors?: Descriptor[];\r\n  /**  Characteristic's uuid */\r\n  uuid: string;\r\n  /**\r\n   *  Characteristic's properties\r\n   *  If the property is defined as a key, the characteristic has that property\r\n   */\r\n  properties?: {\r\n      write?: boolean;\r\n      broadcast?: boolean;\r\n      extendedProps?: boolean;\r\n      writeWithoutResponse?: boolean;\r\n      writeNoResponse?: boolean;\r\n      signedWrite?: boolean;\r\n      read?: boolean;\r\n      notify?: boolean;\r\n      indicate?: boolean;\r\n      authenticatedSignedWrites?: boolean;\r\n      notifyEncryptionRequired?: boolean;\r\n      indicateEncryptionRequired?: boolean\r\n  };\r\n  /**\r\n   *  If the permission is defined as a key, the character has that permission\r\n   */\r\n  permissions?: {\r\n      read?: boolean;\r\n      readEncrypted?: boolean;\r\n      readEncryptedMITM?: boolean\r\n      write?: boolean;\r\n      writeSigned?: boolean;\r\n      writeSignedMITM?: boolean;\r\n      writeEncryptedMITM?: boolean;\r\n      readEncryptionRequired?: boolean;\r\n      writeEncryptionRequired?: boolean;\r\n  };\r\n}\r\n\r\nexport interface Descriptor {\r\n  uuid: string;\r\n}\r\n\r\nexport interface Device extends DeviceInfo {\r\n  /** Device's services */\r\n  services: Service[];\r\n}\r\n\r\nexport interface Services extends DeviceInfo {\r\n  /** Array of service UUIDS */\r\n  services: string[];\r\n}\r\n\r\nexport interface Descriptors extends DeviceInfo {\r\n  /** Characteristic's UUID */\r\n  characteristic: string;\r\n  /** Service's UUID */\r\n  service: string;\r\n  /* Array of descriptor UUIDs */\r\n  descriptors: string[];\r\n}\r\n\r\nexport interface OperationResult extends DeviceInfo {\r\n  /** Characteristic UUID */\r\n  characteristic: string;\r\n  /** Service's UUID */\r\n  service: string;\r\n  /** Base64 encoded string of bytes */\r\n  value: string;\r\n}\r\n\r\nexport interface UnsubscribeResult extends DeviceInfo {\r\n  /** Characteristic UUID */\r\n  characteristic: string;\r\n  /** Service's UUID */\r\n  service: string;\r\n}\r\n\r\nexport interface DescriptorResult extends OperationResult {\r\n  descriptor: string;\r\n}\r\n\r\nexport interface Characteristics extends DeviceInfo {\r\n  /** Service's id */\r\n  service: string;\r\n  /** Array of characteristic objects*/\r\n  characteristics: Characteristic[];\r\n}\r\n\r\nexport interface  InitializeResult {\r\n  /** Device's status */\r\n  status: Status;\r\n  /** The address/identifier provided by the scan's return object */\r\n  address: string;\r\n  /** Service's UUID */\r\n  service: string;\r\n  /** Characteristic UUID */\r\n  characterisitc: string;\r\n  /** This integer value will be incremented every read/writeRequested */\r\n  requestId: number;\r\n  /** Offset value */\r\n  offset: number;\r\n  /** mtu value */\r\n  mtu: number;\r\n  /** Base64 encoded string of bytes */\r\n  value: string;\r\n}\r\n\r\nexport enum BluetoothScanMode {\r\n  SCAN_MODE_OPPORTUNISTIC = -1,\r\n  SCAN_MODE_LOW_POWER = 0,\r\n  SCAN_MODE_BALANCED = 1,\r\n  SCAN_MODE_LOW_LATENCY = 2\r\n}\r\n\r\nexport enum BluetoothMatchMode {\r\n  MATCH_MODE_AGRESSIVE = 1,\r\n  MATCH_MODE_STICKY = 2\r\n}\r\n\r\nexport enum BluetoothMatchNum {\r\n  MATCH_NUM_ONE_ADVERTISEMENT = 1,\r\n  MATCH_NUM_FEW_ADVERTISEMENT = 2,\r\n  MATCH_NUM_MAX_ADVERTISEMENT = 3\r\n}\r\n\r\nexport enum BluetoothCallbackType {\r\n  CALLBACK_TYPE_ALL_MATCHES = 1,\r\n  CALLBACK_TYPE_FIRST_MATCH = 2,\r\n  CALLBACK_TYPE_MATCH_LOST = 4\r\n}\r\n\r\nexport interface Error {\r\n  code: number;\r\n  message: string;\r\n}\r\n\r\n\r\n/**\r\n * @name BluetoothLE\r\n * @description\r\n * This plugin has the most complete implementation for interacting with Bluetooth LE devices on Android, iOS and partially Windows.\r\n * It's a wrap around [randdusing/cordova-plugin-bluetoothle](https://github.com/randdusing/cordova-plugin-bluetoothle/blob/master/readme.md) cordova plugin for Ionic.\r\n * It supports peripheral **and** central modes and covers most of the API methods available on Android and iOS.\r\n *\r\n * @usage\r\n * ```typescript\r\n * import { BluetoothLE } from '@ionic-native/bluetooth-le';\r\n *\r\n *\r\n * constructor(public bluetoothle: BluetoothLE, public plt: Platform) {\r\n *\r\n *  this.plt.ready().then((readySource) => {\r\n *\r\n *    console.log('Platform ready from', readySource);\r\n *\r\n *    this.bluetoothle.initialize().then(ble => {\r\n *      console.log('ble', ble.status) // logs 'enabled'\r\n *    });\r\n *\r\n *   });\r\n * }\r\n * \r\n * ```\r\n * \r\n */\r\n@Plugin({\r\n  pluginName: 'BluetoothLE',\r\n  plugin: 'cordova-plugin-bluetoothle', // npm package name, example: cordova-plugin-camera\r\n  pluginRef: 'bluetoothle', // the variable reference to call the plugin, example: navigator.geolocation\r\n  repo: 'https://github.com/randdusing/cordova-plugin-bluetoothle', // the github repository URL for the plugin\r\n  install: 'ionic cordova plugin add cordova-plugin-bluetoothle', // OPTIONAL install command, in case the plugin requires variables\r\n  installVariables: [], // OPTIONAL the plugin requires variables\r\n  platforms: ['Android', 'iOS'] // Array of platforms supported, example: ['Android', 'iOS']\r\n})\r\n\r\n\r\n@Injectable()\r\nexport class BluetoothLE extends IonicNativePlugin {\r\n\r\n  /**\r\n   * @name initialize\r\n   * @description Initialize Bluetooth on the device\r\n   * @param {InitParams} [params]\r\n   * @returns {(Promise<{ status: 'enabled' | 'disabled'}>)} The callback that is passed initialize status (enabled/disabled)\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  initialize(params?: InitParams):\r\n  Promise<{ status: 'enabled' | 'disabled'}> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name enable (Android)\r\n   * @description Enable Bluetooth on the device. Android support only\r\n   * @returns {Promise<{ status: boolean }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse', sync: true})\r\n  enable():\r\n  Promise<{ status: boolean }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name disable (Android)\r\n   * @description Disable Bluetooth on the device. Android support only\r\n   * @returns void\r\n   */\r\n  @Cordova({callbackOrder: 'reverse', sync: true})\r\n  disable() {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name getAdapterInfo (Android)\r\n   * @description @todo\r\n   * @returns {Promise<{ name: string, address: string, isInitialized: boolean, isEnabled: boolean, isScanning: boolean, isDiscoverable: boolean}>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  getAdapterInfo(): Promise<{\r\n    name: string\r\n    address: string\r\n    isInitialized: boolean\r\n    isEnabled: boolean\r\n    isScanning: boolean\r\n    isDiscoverable: boolean\r\n  }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name startScan\r\n   * @description Scan for Bluetooth LE devices.\r\n   * Since scanning is expensive, stop as soon as possible. The Cordova app should use a timer to limit the scan interval.\r\n   * Android API >= 23 requires ACCESS_COARSE_LOCATION permissions to find unpaired devices.\r\n   * Permissions can be requested by using the hasPermission and requestPermission functions.\r\n   * Android API >= 23 also requires location services to be enabled. Use isLocationEnabled to determine whether location services are enabled.\r\n   * If not enabled, use requestLocation to prompt the location services settings page.\r\n   * @param params Scan params\r\n   * @returns {(Observable<{ status: ScanStatus }>)}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse', observable: true})\r\n  startScan(params: ScanParams):\r\n  Observable<{ status: ScanStatus }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name stopScan\r\n   * @description Stop scan for Bluetooth LE devices. Since scanning is expensive, stop as soon as possible\r\n   * The app should use a timer to limit the scanning time.\r\n   * @returns {Promise<{status: 'scanStopped'}>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  stopScan(): Promise<{ status: 'scanStopped' }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name retrieveConnected\r\n   * @description Retrieved paired Bluetooth LE devices. In iOS, devices that are \"paired\" to will not return during a normal scan.\r\n   * Callback is \"instant\" compared to a scan.\r\n   * @param {{ services: string[] }} An array of service IDs to filter the retrieval by. If no service IDs are specified, no devices will be returned.\r\n   * @returns {Promise<{ devices: DeviceInfo[] }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  retrieveConnected(params?: { services?: string[] }): Promise<{ devices: DeviceInfo[] }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name bond (Android)\r\n   * @description Bond with a device.\r\n   * The device doesn't need to be connected to initiate bonding. Android support only.\r\n   * @param {{ address: string }} params The address/identifier provided by the scan's return object\r\n   * @returns {(Observable<{ status: DeviceInfo }>)}\r\n   * success: \r\n   *    The first success callback should always return with status == bonding.\r\n   *    If the bond is created, the callback will return again with status == bonded.\r\n   *    If the bonding popup is canceled or the wrong code is entered, the callback will return again with status == unbonded.\r\n   * error:\r\n   *    The callback that will be triggered when the bond operation fails\r\n   */\r\n  @Cordova({callbackOrder: 'reverse', observable: true})\r\n  bond(params: { address: string }): Observable<{ status: DeviceInfo }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name unbond (Android)\r\n   * @description Unbond with a device. The device doesn't need to be connected to initiate bonding. Android support only.\r\n   * @param {{address: string}} params The address/identifier\r\n   * @returns {Promise<{ status: DeviceInfo }>}\r\n   *    success: The success callback should always return with status == unbonded, that is passed with device object\r\n   *    error: The callback that will be triggered when the unbond operation fails\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  unbond(params: {address: string}): Promise<{ status: DeviceInfo }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name connect\r\n   * @description Connect to a Bluetooth LE device\r\n   * @param connectSuccess The success callback that is passed with device object\r\n   * @param connectError   The callback that will be triggered when the connect operation fails\r\n   * @param params         The address/identifier\r\n   *\r\n   * @param {{address: string, autoConnect: boolean}} params\r\n   * @returns {(Observable<{ status: DeviceInfo }>)}\r\n   *    success: device object with status\r\n   *    error: The callback that will be triggered when the unbond operation fails\r\n   */\r\n  @Cordova({callbackOrder: 'reverse', observable: true})\r\n  connect(params: {address: string, autoConnect?: boolean}): Observable<{ status: DeviceInfo }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name reconnect\r\n   * @description Reconnect to a previously connected Bluetooth device\r\n   * @param {{address: string}} params The address/identifier\r\n   * @returns {(Observable<{ status: DeviceInfo }>)}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse', observable: true})\r\n  reconnect(params: { address: string }): Observable<{ status: DeviceInfo }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name disconnect\r\n   * @description Disconnect from a Bluetooth LE device.\r\n   *              Note: It's simpler to just call close(). Starting with iOS 10, disconnecting before closing seems required!\r\n   * @param {{address: string}} params The address/identifier\r\n   * @returns {Promise<{ status: DeviceInfo }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  disconnect(params: { address: string }): Promise<{ status: DeviceInfo }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name close\r\n   * @description Close/dispose a Bluetooth LE device.\r\n   * Prior to 2.7.0, you needed to disconnect to the device before closing, but this is no longer the case.\r\n   * Starting with iOS 10, disconnecting before closing seems required!\r\n   * @param {{ address: string }} params The address/identifier\r\n   * @returns {Promise<{ status: DeviceInfo }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  close(params: { address: string }): Promise<{ status: DeviceInfo }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name discover\r\n   * @description Discover all the devices services, characteristics and descriptors.\r\n   * Doesn't need to be called again after disconnecting and then reconnecting.\r\n   * If using iOS, you shouldn't use discover and services/characteristics/descriptors on the same device.\r\n   * There seems to be an issue with calling discover on iOS8 devices, so use with caution.\r\n   * On some Android versions, the discovered services may be cached for a device.\r\n   * Subsequent discover events will make use of this cache.\r\n   * If your device's services change, set the clearCache parameter to force Android to re-discover services.\r\n   * @param {{ address: string, clearCache: boolean }} params The address/identifier\r\n   * @returns {Promise<{ device: Device }>}\r\n   *    success: device object (contains array of service objects)\r\n   *    error: The callback that will be triggered when the unbond operation fails\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  discover(params: { address: string, clearCache?: boolean }): Promise<{ device: Device }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name services (iOS)\r\n   * @description Discover the device's services.\r\n   * Not providing an array of services will return all services and take longer to discover. iOS support only.\r\n   * @param {{address: string, services: string[]}} params\r\n   * @returns {Promise<{ services: Services }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  services(params: { address: string, services?: string[] }): Promise<{ services: Services }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name characteristics (iOS)\r\n   * @description Discover the service's characteristics.\r\n   * Not providing an array of characteristics will return all characteristics and take longer to discover. iOS support only.\r\n   * @param {CharacteristicParams} params Characteristic params\r\n   * @returns {Promise<{ characteristics: Characteristics }>} The service id and an Array of characteristics\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  characteristics(params: CharacteristicParams): Promise<{ characteristics: Characteristics }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name descriptors (iOS)\r\n   * @description Discover the characteristic's descriptors. iOS support only.\r\n   * @param {DescriptorParams} params\r\n   * @returns {Promise<{ descriptors: Descriptors }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  descriptors(params: DescriptorParams): Promise<{ descriptors: Descriptors }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name read\r\n   * @description Read a particular service's characteristic once\r\n   * @param {DescriptorParams} params\r\n   * @returns {Promise<OperationResult>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  read(params: DescriptorParams): Promise<OperationResult> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name subscribe\r\n   * @description Subscribe to a particular service's characteristic.\r\n   * Once a subscription is no longer needed, execute unsubscribe in a similar fashion.\r\n   * The Client Configuration descriptor will automatically be written to enable notification/indication based on the characteristic's properties.\r\n   * @param {DescriptorParams} params\r\n   * @returns {Promise<OperationResult>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse', observable: true})\r\n  subscribe(params: DescriptorParams): Observable<OperationResult> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name unsubscribe\r\n   * @description Unsubscribe to a particular service's characteristic.\r\n   * @param {DescriptorParams} params\r\n   * @returns {Promise<UnsubscribeResult>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  unsubscribe(params: DescriptorParams): Promise<UnsubscribeResult> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name write (limitation on iOS, read below)\r\n   * @description Write a particular service's characteristic\r\n   * Note: no callback will occur on write without response on iOS.\r\n   * @param {WriteCharacteristicParams} params\r\n   * @returns {Promise<OperationResult>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  write(params: WriteCharacteristicParams): Promise<OperationResult> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name write (limitation on iOS, read below)\r\n   * @description Write Quick / Queue, use this method to quickly execute write without response commands when writing more than 20 bytes at a time.\r\n   * Note: no callback will occur on write without response on iOS.\r\n   * @param {WriteCharacteristicParams} params\r\n   * @returns {Promise<OperationResult>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  writeQ(params: WriteCharacteristicParams): Promise<OperationResult> {\r\n    return;\r\n  }\r\n\r\n\r\n  /**\r\n   * @name readDescriptor\r\n   * @description Read a particular characterist's descriptor\r\n   * @param {OperationDescriptorParams} params\r\n   * @returns {Promise<DescriptorResult>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  readDescriptor(params: OperationDescriptorParams): Promise<DescriptorResult> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name writeDescriptor\r\n   * @description Write a particular characteristic's descriptor. Unable to write characteristic configuration directly to keep in line with iOS implementation.\r\n   * Instead use subscribe/unsubscribe, which will automatically enable/disable notification.\r\n   * @param {WriteDescriptorParams} params\r\n   * @returns {Promise<DescriptorResult>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  writeDescriptor(params: WriteDescriptorParams): Promise<DescriptorResult> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name rssi\r\n   * @description Read RSSI of a connected device. RSSI is also returned with scanning.\r\n   * @param {{ address: string }} params\r\n   * @returns {Promise<{ rssi: RSSI }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  rssi(params: { address: string }): Promise<{ rssi: RSSI }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name mtu (Android, Android 5+)\r\n   * @description Set MTU of a connected device. Android only.\r\n   * @param {{ address: string, mtu: number }} params\r\n   * @returns {Promise<{ mtu: MTU }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  mtu(params: { address: string, mtu?: number }): Promise<{ mtu: MTU }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name requestConnectionPriority (Android, Android 5+)\r\n   * @description Request a change in the connection priority to improve throughput when transfer large amounts of data via BLE.\r\n   * Android support only. iOS will return error.\r\n   * @param {{ address: string, connectionPriority: ConnectionPriority }} params\r\n   * @returns {Promise<DeviceInfo>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  requestConnectionPriority(params: { address: string, connectionPriority: ConnectionPriority }): Promise<DeviceInfo> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name isInitialized\r\n   * @description Determine whether the adapter is initialized. No error callback. Returns true or false\r\n   * @returns {Promise<{ isInitialized: boolean }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  isInitialized(): Promise<{ isInitialized: boolean }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name isEnabled\r\n   * @description Determine whether the adapter is enabled. No error callback\r\n   * @returns {Promise<{ isEnabled: boolean }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  isEnabled(): Promise<{ isEnabled: boolean }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name isScanning\r\n   * @description Determine whether the adapter is scanning. No error callback. Returns true or false\r\n   * @returns {Promise<{ isScanning: boolean }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  isScanning(): Promise<{ isScanning: boolean }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name isBonded (Android)\r\n   * @description Determine whether the device is bonded or not, or error if not initialized. Android support only.\r\n   * @param {{ address: string }} params\r\n   * @returns {Promise<BondedStatus>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  isBonded(params: { address: string }): Promise<BondedStatus> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name wasConnected\r\n   * @description Determine whether the device was connected, or error if not initialized.\r\n   * @param {{ address: string }} params\r\n   * @returns {Promise<PrevConnectionStatus>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  wasConnected(params: { address: string }): Promise<PrevConnectionStatus> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name isConnected\r\n   * @description Determine whether the device is connected, or error if not initialized or never connected to device\r\n   * @param {{ address: string }} params\r\n   * @returns {Promise<CurrConnectionStatus>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  isConnected(params: { address: string }): Promise<CurrConnectionStatus> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name isDiscovered\r\n   * @description Determine whether the device's characteristics and descriptors have been discovered, or error if not initialized or not connected to device.\r\n   * @param {{ address: string }} params\r\n   * @returns {Promise<DiscoverStatus>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  isDiscovered(params: { address: string }): Promise<DiscoverStatus> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name hasPermission (useful only for Android 6+ / API 23)\r\n   * @description Determine whether coarse location privileges are granted since scanning for unpaired devices requires it in Android API 23\r\n   * @returns {Promise<{ hasPermission: boolean }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  hasPermission(): Promise<{ hasPermission: boolean }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name requestPermission (useful only for Android 6+ / API 23)\r\n   * @description Request coarse location privileges since scanning for unpaired devices requires it in Android API 23.\r\n   * Will return an error if called on iOS or Android versions prior to 6.0.\r\n   * @returns {Promise<{ requestPermission: boolean }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  requestPermission(): Promise<{ requestPermission: boolean }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name isLocationEnabled (useful only for Android 6+ / API 23)\r\n   * @description Determine if location services are enabled or not. Location Services are required to find devices in Android API 23\r\n   * @returns {Promise<{ isLocationEnabled: boolean }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  isLocationEnabled(): Promise<{ isLocationEnabled: boolean }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name requestLocation (useful only for Android 6+ / API 23)\r\n   * @description Prompt location services settings pages. requestLocation property returns whether location services are enabled or disabled.\r\n   * Location Services are required to find devices in Android API 23.\r\n   * @returns {Promise<{ requestLocation: boolean }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  requestLocation(): Promise<{ requestLocation: boolean }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name initializePeripheral\r\n   * @description Initialize Bluetooth on the device. Must be called before anything else.\r\n   * Callback will continuously be used whenever Bluetooth is enabled or disabled.\r\n   * @param {InitPeripheralParams} [params]\r\n   * @returns {Observable<InitializeResult>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  initializePeripheral(params?: InitPeripheralParams ): Observable<InitializeResult> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name addService\r\n   * @description Add a service with characteristics and descriptors. If more than one service is added, add them sequentially\r\n   * @param {{ service: string, characteristics: Characteristic[] }} params\r\n   * @returns {Promise<{ service: string, status: Status }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  addService(params: { service: string, characteristics: Characteristic[] }): Promise<{ service: string, status: Status }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name removeService\r\n   * @description Remove a service\r\n   * @param {{ service: string }} params\r\n   * @returns {Promise<{ service: string, status: Status }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  removeService(params: { service: string }): Promise<{ service: string, status: Status }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name removeAllServices\r\n   * @description Remove all services\r\n   * @returns {Promise<{ status: Status }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  removeAllServices(): Promise<{ status: Status }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name startAdvertising (different behavior on Android/iOS, read below)\r\n   * @description Start advertising as a BLE device. \r\n   * Note: This needs to be improved so services can be used for both Android and iOS.\r\n   * On iOS, the advertising devices likes to rename itself back to the name of the device, i.e. Rand' iPhone\r\n   * @param {AdvertisingParams} params\r\n   * @returns {Promise<{ status: Status }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  startAdvertising(params: AdvertisingParams): Promise<{ status: Status }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name stopAdvertising\r\n   * @description Stop advertising\r\n   * @returns {Promise<{ status: Status }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  stopAdvertising(): Promise<{ status: Status }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name isAdvertising\r\n   * @description Determine if app is advertising or not.\r\n   * @returns {Promise<{ status: boolean }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  isAdvertising(): Promise<{ status: boolean }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name respond\r\n   * @description Respond to a read or write request\r\n   * @param {RespondParams} params\r\n   * @returns {Promise<{ status: Status }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  respond(params: RespondParams): Promise<{ status: Status }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name notify\r\n   * @description Update a value for a subscription. Currently all subscribed devices will receive update.\r\n   * Device specific updates will be added in the future.\r\n   * If sent equals false in the return value, you must wait for the peripheralManagerIsReadyToUpdateSubscribers event before sending more updates.\r\n   * @param {NotifyParams} params\r\n   * @returns {Promise<{ status: Status, sent: boolean }>}\r\n   */\r\n  @Cordova({callbackOrder: 'reverse'})\r\n  notify(params: NotifyParams): Promise<{ status: Status, sent: boolean }> {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name encodedStringToBytes\r\n   * @description Helper function to convert a base64 encoded string from a characteristic or descriptor value into a uint8Array object\r\n   * @param {string} str\r\n   * @returns {Uint8Array}\r\n   */\r\n  @Cordova({sync: true})\r\n  encodedStringToBytes(value: string): Uint8Array {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name bytesToEncodedString\r\n   * @description Helper function to convert a unit8Array to a base64 encoded string for a characteric or descriptor write\r\n   * @param {Uint8Array} bytes\r\n   * @returns {string}\r\n   */\r\n  @Cordova({sync: true})\r\n  bytesToEncodedString(value: Uint8Array): string {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name stringToBytes\r\n   * @description Helper function to convert a string to bytes\r\n   * @param {Uint8Array} value\r\n   * @returns {string}\r\n   */\r\n  @Cordova({sync: true})\r\n  stringToBytes(value: Uint8Array): string {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @name bytesToString\r\n   * @description Helper function to convert bytes to a string.\r\n   * @param {Uint8Array} value\r\n   * @returns {string}\r\n   */\r\n  @Cordova({sync: true})\r\n  bytesToString(value: Uint8Array): string {\r\n    return;\r\n  }\r\n\r\n  @CordovaProperty\r\n  SCAN_MODE_OPPORTUNISTIC: number;\r\n  @CordovaProperty\r\n  SCAN_MODE_LOW_POWER: number;\r\n  @CordovaProperty\r\n  SCAN_MODE_BALANCED: number;\r\n  @CordovaProperty\r\n  SCAN_MODE_LOW_LATENCY: number;\r\n  @CordovaProperty\r\n  MATCH_MODE_AGRESSIVE: number;\r\n  @CordovaProperty\r\n  MATCH_MODE_STICKY: number;\r\n  @CordovaProperty\r\n  MATCH_NUM_ONE_ADVERTISEMENT: number;\r\n  @CordovaProperty\r\n  MATCH_NUM_FEW_ADVERTISEMENT: number;\r\n  @CordovaProperty\r\n  MATCH_NUM_MAX_ADVERTISEMENT: number;\r\n  @CordovaProperty\r\n  CALLBACK_TYPE_ALL_MATCHES: number;\r\n  @CordovaProperty\r\n  CALLBACK_TYPE_FIRST_MATCH: number;\r\n  @CordovaProperty\r\n  CALLBACK_TYPE_MATCH_LOST: number;\r\n}\r\n"]}